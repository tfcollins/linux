---
wiki-source: https://wiki.analog.com/resources/tools-software/linux-drivers/drm/adv7511
title: ADV7511: 225 MHZ, HIGH PERFORMANCE HDMIÂ® TRANSMITTER WITH ARC
source: /home/runner/work/linux/linux/drivers/media/i2c/adv7511-v4l2.c
compatibles: adv7511-v4l2
---
# ADV7511 HDMI transmitter Linux Driver

### Supported Devices

-   [ADV7511](https://analog.com/ADV7511)
-   [ADV7511W](https://analog.com/ADV7511W)
-   [ADV7513](https://analog.com/ADV7513)
-   [ADV7533](https://analog.com/ADV7533)
-   [ADV7535](https://analog.com/ADV7535)

### Reference Circuits

-   [CN0224](https://analog.com/CN0224)

### Evaluation Boards

-   [EVAL-ADV7511W](https://analog.com/EVAL-ADV7511W)
-   [EVAL-ADV7612](https://analog.com/EVAL-ADV7612)
-   [EVAL-ADV7612-7511](https://analog.com/EVAL-ADV7612-7511)
-   [EVAL-ADV7842](https://analog.com/EVAL-ADV7842)
-   [EVAL-ADV7842-7511](https://analog.com/EVAL-ADV7842-7511)

### Description

The ADV7511 driver is implemented as a DRM encoder slave driver. In a typical board design the ADV7511 is not used as a standalone component but rather as a HDMI encoder fronted for some other devices with a graphics core, like a SoC or a FPGA. Implementing the ADV7511 driver as a DRM encoder slave driver allows to reuse the driver between different platforms which use the ADV7511.

For an example implementation of a DRM driver using the ADV7511 please refer to Linux driver for the Analog Devices example HDL design for the Xilinx Zync plus ADV7511 designs.

The driver supports audio via HDMI as well by implementing a ASoC codec driver. This again allows to reuse the driver for a varieties of different platforms.

## Source Code

### Status

<table>
<thead>
<tr class="header">
<th>Source</th>
<th>Mainlined?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="git.linux.org&gt;drivers/gpu/drm/bridge/adv7511/">git</a></td>
<td><a href="git.linux.org&gt;drivers/gpu/drm/bridge/adv7511/">Yes</a></td>
</tr>
</tbody>
</table>

### Files

<table>
<thead>
<tr class="header">
<th>Function</th>
<th>File</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>driver</td>
<td><a href="git.linux.org&gt;drivers/gpu/drm/bridge/adv7511/adv7511_drv.c">drivers/gpu/drm/bridge/adv7511/adv7511_drv.c</a></td>
</tr>
<tr class="even">
<td>driver</td>
<td><a href="git.linux.org&gt;drivers/gpu/drm/bridge/adv7511/adv7511_audio.c">drivers/gpu/drm/bridge/adv7511/adv7511_audio.c</a></td>
</tr>
<tr class="odd">
<td>driver</td>
<td><a href="git.linux.org&gt;drivers/gpu/drm/bridge/adv7511/adv7533.c">drivers/gpu/drm/bridge/adv7511/adv7533.c</a></td>
</tr>
<tr class="even">
<td>include</td>
<td><a href="git.linux.org&gt;drivers/gpu/drm/bridge/adv7511/adv7511.h">drivers/gpu/drm/bridge/adv7511/adv7511.h</a></td>
</tr>
</tbody>
</table>

## Example platform device initialization

### DRM

Usually the DRM encoder slave will be instantiated by a DRM encoder driver. After the encoder slave has been instantiated it needs to be configured by the DRM encoder driver. The configuration includes settings like physical connection to the host graphics core as well as the output video format. If necessary the configuration can be changed at runtime, e.g. to change the output format if a HDMI sink with different capabilities is connected.

Configuration for the ADV7511 is done through the adv7511_video_input_config which should be passed to the slave encoder's set_config callback function.

``` c
/**
 * enum adv7511_input_style - Selects the input format style
 * ADV7511_INPUT_STYLE1: Use input style 1
 * ADV7511_INPUT_STYLE2: Use input style 2
 * ADV7511_INPUT_STYLE3: Use input style 3
 **/
enum adv7511_input_style {
    ADV7511_INPUT_STYLE1 = 2,
    ADV7511_INPUT_STYLE2 = 1,
    ADV7511_INPUT_STYLE3 = 3,
};

/**
 * enum adv7511_input_id - Selects the input format id
 * @ADV7511_INPUT_ID_24BIT_RGB444_YCbCr444: Input pixel format is 24-bit 444 RGB
 *                      or 444 YCbCR with separate syncs
 * @ADV7511_INPUT_ID_16_20_24BIT_YCbCr422_SEPARATE_SYNC:
 * @ADV7511_INPUT_ID_16_20_24BIT_YCbCr422_EMBEDDED_SYNC:
 * @ADV7511_INPUT_ID_8_10_12BIT_YCbCr422_SEPARATE_SYNC:
 * @ADV7511_INPUT_ID_8_10_12BIT_YCbCr422_EMBEDDED_SYNC:
 * @ADV7511_INPUT_ID_12_15_16BIT_RGB444_YCbCr444:
 **/
enum adv7511_input_id {
    ADV7511_INPUT_ID_24BIT_RGB444_YCbCr444 = 0,
    ADV7511_INPUT_ID_16_20_24BIT_YCbCr422_SEPARATE_SYNC = 1,
    ADV7511_INPUT_ID_16_20_24BIT_YCbCr422_EMBEDDED_SYNC = 2,
    ADV7511_INPUT_ID_8_10_12BIT_YCbCr422_SEPARATE_SYNC = 3,
    ADV7511_INPUT_ID_8_10_12BIT_YCbCr422_EMBEDDED_SYNC = 4,
    ADV7511_INPUT_ID_12_15_16BIT_RGB444_YCbCr444 = 5,
};

/**
 * enum adv7511_input_bit_justifiction - Selects the input format bit justifiction
 * ADV7511_INPUT_BIT_JUSTIFICATION_EVENLY: Input bits are evenly distributed
 * ADV7511_INPUT_BIT_JUSTIFICATION_RIGHT: Input bit signals have right justification
 * ADV7511_INPUT_BIT_JUSTIFICATION_LEFT: Input bit signals have left justification
 **/
enum adv7511_input_bit_justifiction {
    ADV7511_INPUT_BIT_JUSTIFICATION_EVENLY = 0,
    ADV7511_INPUT_BIT_JUSTIFICATION_RIGHT = 1,
    ADV7511_INPUT_BIT_JUSTIFICATION_LEFT = 2,
};

/**
 * enum adv7511_input_color_depth - Selects the input format color depth
 * @ADV7511_INPUT_COLOR_DEPTH_8BIT: Input format color depth is 8 bits per channel
 * @ADV7511_INPUT_COLOR_DEPTH_10BIT: Input format color dpeth is 10 bits per channel
 * @ADV7511_INPUT_COLOR_DEPTH_12BIT: Input format color depth is 12 bits per channel
 **/
enum adv7511_input_color_depth {
    ADV7511_INPUT_COLOR_DEPTH_8BIT = 3,
    ADV7511_INPUT_COLOR_DEPTH_10BIT = 1,
    ADV7511_INPUT_COLOR_DEPTH_12BIT = 2,
};

/**
 * enum adv7511_input_sync_pulse - Selects the sync pulse
 * @ADV7511_INPUT_SYNC_PULSE_DE: Use the DE signal as sync pulse
 * @ADV7511_INPUT_SYNC_PULSE_HSYNC: Use the HSYNC signal as sync pulse
 * @ADV7511_INPUT_SYNC_PULSE_VSYNC: Use the VSYNC signal as sync pulse
 * @ADV7511_INPUT_SYNC_PULSE_NONE: No external sync pulse signal
 **/
enum adv7511_input_sync_pulse {
    ADV7511_INPUT_SYNC_PULSE_DE = 0,
    ADV7511_INPUT_SYNC_PULSE_HSYNC = 1,
    ADV7511_INPUT_SYNC_PULSE_VSYNC = 2,
    ADV7511_INPUT_SYNC_PULSE_NONE = 3,
};

/**
 * enum adv7511_input_clock_delay - Delay for the video data input clock
 * @ADV7511_INPUT_CLOCK_DELAY_MINUS_1200PS: -1200 pico seconds delay
 * @ADV7511_INPUT_CLOCK_DELAY_MINUS_800PS: -800 pico seconds delay
 * @ADV7511_INPUT_CLOCK_DELAY_MINUS_400PS: -400 pico seconds delay
 * @ADV7511_INPUT_CLOCK_DELAY_NONE: No delay
 * @ADV7511_INPUT_CLOCK_DELAY_PLUS_400PS: 400 pico seconds delay
 * @ADV7511_INPUT_CLOCK_DELAY_PLUS_800PS: 800 pico seconds delay
 * @ADV7511_INPUT_CLOCK_DELAY_PLUS_1200PS: 1200 pico seconds delay
 * @ADV7511_INPUT_CLOCK_DELAY_PLUS_1600PS: 1600 pico seconds delay
 **/
enum adv7511_input_clock_delay {
    ADV7511_INPUT_CLOCK_DELAY_MINUS_1200PS = 0,
    ADV7511_INPUT_CLOCK_DELAY_MINUS_800PS = 1,
    ADV7511_INPUT_CLOCK_DELAY_MINUS_400PS = 2,
    ADV7511_INPUT_CLOCK_DELAY_NONE = 3,
    ADV7511_INPUT_CLOCK_DELAY_PLUS_400PS = 4,
    ADV7511_INPUT_CLOCK_DELAY_PLUS_800PS = 5,
    ADV7511_INPUT_CLOCK_DELAY_PLUS_1200PS = 6,
    ADV7511_INPUT_CLOCK_DELAY_PLUS_1600PS = 7,
};

/**
 * enum adv7511_csc_scaling - HDMI videostream format
 * @ADV7511_OUTPUT_FORMAT_RGB_444: Output format is RGB 444
 * @ADV7511_OUTPUT_FORMAT_YCBCR_422: Output format is YCbCr 422
 * @ADV7511_OUTPUT_FORMAT_YCBCR_444: Output format is YCbCr 444
 **/
enum adv7511_output_format {
    ADV7511_OUTPUT_FORMAT_RGB_444 = 0,
    ADV7511_OUTPUT_FORMAT_YCBCR_422 = 1,
    ADV7511_OUTPUT_FORMAT_YCBCR_444 = 2,
};

/**
 * enum adv7511_sync_polarity - Polarity for the input sync signals
 * ADV7511_SYNC_POLARITY_PASSTHROUGH:  Sync polarity matches that of the currently
 *                  configured mode.
 * ADV7511_SYNC_POLARITY_LOW:       Sync polarity is low
 * ADV7511_SYNC_POLARITY_HIGH:      Sync polarity is high
 *
 * If the polarity is set to either ADV7511_SYNC_POLARITY_LOW or
 * ADV7511_SYNC_POLARITY_HIGH the ADV7511 will internally invert the signal if
 * it is required to match the sync polarity setting for the currently selected
 * mode. If the polarity is set to ADV7511_SYNC_POLARITY_PASSTHROUGH, the ADV7511
 * will route the signal unchanged, this is useful if the upstream graphics core
 * will already generate the sync singals with the correct polarity.
 **/
enum adv7511_sync_polarity {
    ADV7511_SYNC_POLARITY_PASSTHROUGH,
    ADV7511_SYNC_POLARITY_LOW,
    ADV7511_SYNC_POLARITY_HIGH,
};

/**
 * enum adv7511_csc_scaling - Scaling factor for the ADV7511 CSC
 * @ADV7511_CSC_SCALING_1: CSC results are not scaled
 * @ADV7511_CSC_SCALING_2: CSC results are scaled by a factor of two
 * @ADV7511_CSC_SCALING_4: CSC results are scalled by a factor of four
 **/
enum adv7511_csc_scaling {
    ADV7511_CSC_SCALING_1 = 0,
    ADV7511_CSC_SCALING_2 = 1,
    ADV7511_CSC_SCALING_4 = 2,
};

/**
 * enum adv7511_timing_gen_seq - Selects the order in which timing adjustments are performed
 * @ADV7511_TIMING_GEN_SEQ_SYN_ADJ_FIRST: Sync adjustment first, then DE generation
 * @ADV7511_TIMING_GEN_SEQ_DE_GEN_FIRST: DE generation first, then sync adjustment
 *
 * This setting is only relevant if both DE generation and sync adjustment are
 * active.
 **/
enum adv7511_timing_gen_seq {
    ADV7511_TIMING_GEN_SEQ_SYN_ADJ_FIRST = 0,
    ADV7511_TIMING_GEN_SEQ_DE_GEN_FIRST = 1,
};


/**
 * enum adv7511_up_conversion - Selects the upscaling conversion method
 * @ADV7511_UP_CONVERSION_ZERO_ORDER: Use zero order up conversion
 * @ADV7511_UP_CONVERSION_FIRST_ORDER: Use first order up conversion
 *
 * This used when converting from a 4:2:2 format to a 4:4:4 format.
 **/
enum adv7511_up_conversion {
    ADV7511_UP_CONVERSION_ZERO_ORDER = 0,
    ADV7511_UP_CONVERSION_FIRST_ORDER = 0,
};

/**
 * struct adv7511_video_input_config - Describes adv7511 hardware configuration
 * @id:             Video input format id
 * @input_style:        Video input format style
 * @sync_pulse:         Select the sync pulse
 * @clock_delay:        Clock delay for the input clock
 * @reverse_bitorder:       Reverse video input signal bitorder
 * @bit_justification:      Video input format bit justification
 * @up_conversion:      Selects the upscaling conversion method
 * @input_color_depth:      Input video format color depth
 * @tmds_clock_inversion:   Whether to invert the TDMS clock
 * @vsync_polartity:        vsync input signal configuration
 * @hsync_polartity:        hsync input signal configuration
 * @csc_enable:         Whether to enable color space conversion
 * @csc_scaling_factor:     Color space conversion scaling factor
 * @csc_coefficents:        Color space conversion coefficents
 * @output_format:      Video output format
 * @timing_gen_seq:     Selects the order in which sync DE generation
 *              and sync adjustment are performt.
 * @hdmi_mode:          Whether to use HDMI or DVI output mode
 **/
struct adv7511_video_input_config {
    enum adv7511_input_id id;
    enum adv7511_input_style input_style;
    enum adv7511_input_sync_pulse sync_pulse;
    enum adv7511_input_clock_delay clock_delay;
    bool reverse_bitorder;
    enum adv7511_input_bit_justifiction bit_justification;
    enum adv7511_up_conversion up_conversion;
    enum adv7511_input_color_depth input_color_depth;
    bool tmds_clock_inversion;

    enum adv7511_sync_polarity vsync_polarity;
    enum adv7511_sync_polarity hsync_polarity;

    bool csc_enable;
    enum adv7511_csc_scaling csc_scaling_factor;
    const uint16_t *csc_coefficents;

    enum adv7511_output_format output_format;
    enum adv7511_timing_gen_seq timing_gen_seq;
    bool hdmi_mode;
};
```

#### Example Configuration

``` c

static const uint16_t adv7511_csc_ycbcr_to_rgb[] = {
    0x0734, 0x04ad, 0x0000, 0x1c1b,
    0x1ddc, 0x04ad, 0x1f24, 0x0135,
    0x0000, 0x04ad, 0x087c, 0x1b77,
};

static const struct adv7511_video_input_config adv7511_config_zc702 = {
    .id = ADV7511_INPUT_ID_16_20_24BIT_YCbCr422_SEPARATE_SYNC,
    .input_style = ADV7511_INPUT_STYLE1,
    .sync_pulse = ADV7511_INPUT_SYNC_PULSE_NONE,
    .clock_delay = ADV7511_INPUT_CLOCK_DELAY_NONE,
    .reverse_bitorder = false,
    .vsync_polarity = ADV7511_SYNC_POLARITY_HIGH,
    .hsync_polarity = ADV7511_SYNC_POLARITY_HIGH,
    .up_conversion = ADV7511_UP_CONVERSION_ZERO_ORDER,
    .input_color_depth = ADV7511_INPUT_COLOR_DEPTH_8BIT,
    .output_format = ADV7511_OUTPUT_FORMAT_RGB_444,
    .csc_enable = true,
    .csc_coefficents = adv7511_csc_ycbcr_to_rgb,
    .csc_scaling_factor = ADV7511_CSC_SCALING_4,
    .bit_justification = ADV7511_INPUT_BIT_JUSTIFICATION_RIGHT,
    .tmds_clock_inversion = true,
};

[...]
    struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);

    sfuncs->set_config(encoder, &adv7511_config_zc702);
[...]

```

### ASoC

### DAI configuration

The codec driver registers one DAI: **adau-hifi**

##### Supported DAI formats

<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Supported by driver</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SND_SOC_DAIFMT_I2S</td>
<td>yes</td>
<td>I2S mode</td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_RIGHT_J</td>
<td>yes</td>
<td>Right Justified mode</td>
</tr>
<tr class="odd">
<td>SND_SOC_DAIFMT_LEFT_J</td>
<td>yes</td>
<td>Left Justified mode</td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_DSP_A</td>
<td>no</td>
<td>data MSB after FRM LRC</td>
</tr>
<tr class="odd">
<td>SND_SOC_DAIFMT_DSP_B</td>
<td>no</td>
<td>data MSB during FRM LRC</td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_AC97</td>
<td>no</td>
<td>AC97 mode</td>
</tr>
<tr class="odd">
<td>SND_SOC_DAIFMT_PDM</td>
<td>no</td>
<td>Pulse density modulation</td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_SPDIF</td>
<td>yes</td>
<td>SPDIF</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_NB_NF</td>
<td>yes</td>
<td>Normal bit- and frameclock</td>
</tr>
<tr class="odd">
<td>SND_SOC_DAIFMT_NB_IF</td>
<td>no</td>
<td>Normal bitclock, inverted frameclock</td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_IB_NF</td>
<td>yes</td>
<td>Inverted frameclock, normal bitclock</td>
</tr>
<tr class="odd">
<td>SND_SOC_DAIFMT_IB_IF</td>
<td>no</td>
<td>Inverted bit- and frameclock</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>SND_SOC_DAIFMT_CBM_CFM</td>
<td>no</td>
<td>Codec bit- and frameclock master</td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_CBS_CFM</td>
<td>no</td>
<td>Codec bitclock slave, frameclock master</td>
</tr>
<tr class="odd">
<td>SND_SOC_DAIFMT_CBM_CFS</td>
<td>no</td>
<td>Codec bitclock master, frameclock slave</td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_CBS_CFS</td>
<td>yes</td>
<td>Codec bit- and frameclock slave</td>
</tr>
</tbody>
</table>

##### Example DAI configuration

``` c
static struct snd_soc_dai_link hdmi_dai_link = {
    .name = "HDMI",
    .stream_name = "HDMI",
    .cpu_dai_name = "75c00000.axi-spdif-tx",
    .platform_name = "xilinx_pcm_audio.2",
    .codec_name = "adv7511.0-0039",
    .codec_dai_name = "adv7511",
    .dai_fmt = SND_SOC_DAIFMT_SPDIF |
            SND_SOC_DAIFMT_NB_NF |
            SND_SOC_DAIFMT_CBS_CFS,
};

static struct snd_soc_card hdmi_card = {
    .name = "HDMI monitor",
    .owner = THIS_MODULE,
    .dai_link = &hdmi_dai_link,
    .num_links = 1,
};
```

## Enabling Linux driver support

Configure kernel with "make menuconfig" (alternatively use "make xconfig" or
"make qconfig")

:::{NOTE} <!-- ATTRS: round="" help="" -->

The ADV7511 Driver depends on **CONFIG_DRM** and **CONFIG_I2C**

:::


    Linux Kernel Configuration
        Device Drivers  --->
            Graphics support  --->  
                <*> Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)  ---> 
                ...
                <*> AV7511 encoder

## More information

-   [AXI HDMI HDL Linux Driver](..//drm/hdl-axi-hdmi)
-   [HDL AXI SPIDF Linux Driver](..//sound/hdl-axi-spidf)
-   [Linux with HDMI video output on the ZED and ZC702 boards](..//platforms/zynq)

<!-- CMDS: noheader firstseconly noeditbtn -->
```{include} resources_tools-software_linux-drivers_need_help_SUB_need_help.md
```
