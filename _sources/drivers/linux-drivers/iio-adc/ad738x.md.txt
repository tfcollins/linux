---
wiki-source: https://wiki.analog.com/resources/tools-software/linux-drivers/iio-adc/ad738x
title: AD7380: 4MSPS Dual Simultaneous Sampling, 16-BIT SAR ADC, Differential Input
---

# AD738x IIO Dual Channel Serial ADC Linux Driver

### Supported Devices

-   [AD7380](https://analog.com/AD7380)
-   [AD7381](https://analog.com/AD7381)
-   [AD7386](https://analog.com/AD7386)
-   [AD7387](https://analog.com/AD7387)
-   [AD7388](https://analog.com/AD7388)

### Evaluation Boards

-   [EVAL-AD738xFMCZ](https://analog.com/EVAL-AD738xFMCZ)

### Description

This is a Linux industrial I/O ([IIO](/software/linux/docs/iio/iio)) subsystem driver, targeting dual or quad channel serial interface ADCs.
The industrial I/O subsystem provides a unified framework for drivers for many different types of converters and sensors using a number of different physical interfaces (i2c, spi, etc).
See [IIO](/software/linux/docs/iio/iio) for more information.

## Source Code

### Status

<table>
<thead>
<tr class="header">
<th>Source</th>
<th>Mainlined?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://github.com/analogdevicesinc/linux/blob/master/drivers/iio/adc/ad738x.c">git</a></td>
<td>[No]</td>
</tr>
</tbody>
</table>

### Files

<table>
<thead>
<tr class="header">
<th>Function</th>
<th>File</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>driver</td>
<td><a href="https://github.com/analogdevicesinc/linux/blob/master/drivers/iio/adc/ad738x.c">https://github.com/analogdevicesinc/linux/blob/master/drivers/iio/adc/ad738x.c</a></td>
</tr>
</tbody>
</table>

### Devicetree

Required devicetree properties:

-   compatible: Needs to be the name of the device. E.g. "ad7380"
-   reg: The chipselect number used for the device
-   spi-max-frequency: Maximum SPI clock frequency.
-   spi-cpol: Needs to be set for the correct SPI mode
-   vref-supply: Phandle to the fixed regulator

```{=html}
<!-- -->
```
            adc_vref: fixedregulator@0 {
                compatible = "regulator-fixed";
            regulator-name = "fixed-supply";
            regulator-min-microvolt = <2500000>;
            regulator-max-microvolt = <2500000>;
            regulator-boot-on;
        };

        #address-cells = <1>;
        #size-cells = <0>;
        status = "okay";

        ad738x@0 {
            compatible = "ad7380";
            reg = <0>;
            spi-max-frequency = <1000000>;
            spi-cpol;
            vref-supply = <&adc_vref>;
        };

## Driver testing

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```{code-block} bash
root:/> **cd /sys/bus/iio/devices/**
root:/sys/bus/iio/devices> ls
iio:device0

root:/sys/bus/iio/devices> **cd iio:device0**

root:/sys/bus/iio/devices/iio:device0> **ls -l**
drwxr-xr-x 2 root root 0 Sep 12 20:11 buffer
-r--r--r-- 1 root root 4096 Sep 12 20:11 dev
-rw-r--r-- 1 root root 4096 Sep 12 20:11 in_voltage0_raw
-rw-r--r-- 1 root root 4096 Sep 12 20:11 in_voltage1_raw
-rw-r--r-- 1 root root 4096 Sep 12 20:11 in_voltage_scale
-r--r--r-- 1 root root 4096 Sep 12 20:11 name
lrwxrwxrwx 1 root root 0 Sep 12 20:11 of_node -> ../../../../../../../../firmware/devicetree/base/soc/spi@7e204000/ad738x@0
drwxr-xr-x 2 root root 0 Sep 12 20:11 power
drwxr-xr-x 2 root root 0 Sep 12 20:11 scan_elements
lrwxrwxrwx 1 root root 0 Sep 12 20:11 subsystem -> ../../../../../../../../bus/iio
drwxr-xr-x 2 root root 0 Sep 12 20:11 trigger
-rw-r--r-- 1 root root 4096 Sep 12 20:11 uevent
```
:::


##### Show device name

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```{code-block} bash
root:/sys/bus/iio/devices/iio:device0> **cat name**
ad7380
```
:::


##### Show scale

**Description:**
scale to be applied to in_voltage0_raw in order to obtain the measured voltage in millivolts.

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```{code-block} bash
root:/sys/bus/iio/devices/iio:device0> **cat in_voltage_scale**
0.076293945
```
:::


##### Show channel 0 measurement

**Description:**
Raw unscaled voltage measurement on channel 0

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```{code-block} bash
root:/sys/bus/iio/devices/iio:device0> **cat in_voltage0_raw**
28583
```
:::


**U** = *in_voltage0_raw * in_voltage_scale* = 28583 * 0.076293945 = **2180.70 *mV***

### Trigger management

If deviceX supports triggered sampling, it's a so called trigger consumer and there will be an additional folder /sys/bus/iio/device/iio:deviceX/trigger. In this folder there is a file called current_trigger, allowing controlling and viewing the current trigger source connected to deviceX. Available trigger sources can be identified by reading the name file /sys/bus/iio/devices/triggerY/name. The same trigger source can connect to multiple devices, so a single trigger may initialize data capture or reading from a number of sensors, converters, etc.

This driver uses **high resolution timers** as interrupt source

**Description:**
Hrtimer triggers creation and destruction

Loading iio-trig-hrtimer module will register hrtimer trigger types allowing users to create hrtimer triggers:

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```{code-block} bash
root:/sys/kernel/config/iio/triggers/hrtimer/> **mkdir trigger0**
```
:::


**Description:**
Read name of trigger0

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```{code-block} bash
root:/sys/bus/iio/devices/trigger0/> **cat name**
trigger0
```
:::


**Description:**
Configure the sampling frequency of trigger0

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```{code-block} bash
root:/sys/bus/iio/devices/trigger0/> **echo 500 > sampling_frequency**
trigger0
```
:::


**Description:**
Make trigger0 to current trigger of device0

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```{code-block} bash
root:/sys/bus/iio/devices/iio:device0/> **echo trigger0 > trigger/current_trigger **
```
:::


**Description:**
Read current trigger source of device0

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```{code-block} bash
root:/sys/bus/iio/devices/iio:device0/trigger> **cat current_trigger**
trigger0
```
:::


### Buffer management

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```{code-block} bash
root:/sys/bus/iio/devices/iio:device0/buffer> ls
**enable** **length** **watermark**
root:/sys/bus/iio/devices/iio:device0/buffer>
```
:::


Every buffer implementation features a set of files:

**length**
Get/set the number of sample sets that may be held by the buffer.

**enable**
Enables/disables the buffer. This file should be written last, after length and selection of scan elements

**scan_elements**
The scan_elements directory contains interfaces for elements that will be captured for a single triggered sample set in the buffer.

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```{code-block} bash
root:/sys/bus/iio/devices/iio:device0/scan_elements> ls
in_voltage0_en in_voltage0_index in_voltage0_type in_voltage1_en in_voltage1_index in_voltage1_type
root:/sys/bus/iio/devices/iio:device0/scan_elements>
```
:::


**in_voltageX_en / in_voltageX-voltageY_en / timestamp_en:**
Scan element control for triggered data capture. Writing 1 will enable the scan element, writing 0 will disable it

**in_voltageX_type / in_voltageX-voltageY_type / timestamp_type:**
Description of the scan element data storage within the buffer and therefore in the form in which it is read from user-space. Form is [s|u]bits/storage-bits. s or u specifies if signed (2's complement) or unsigned. bits is the number of bits of data and storage-bits is the space (after padding) that it occupies in the buffer. Note that some devices will have additional information in the unused bits so to get a clean value, the bits value must be used to mask the buffer output value appropriately. The storage-bits value also specifies the data alignment. So u12/16 will be a unsigned 12 bit integer stored in a 16 bit location aligned to a 16 bit boundary. For other storage combinations this attribute will be extended appropriately.

**in_voltageX_index / in_voltageX-voltageY_index / timestamp_index:**
A single positive integer specifying the position of this scan element in the buffer. Note these are not dependent on what is enabled and may not be contiguous. Thus for user-space to establish the full layout these must be used in conjunction with all _en attributes to establish which channels are present, and the relevant _type attributes to establish the data storage format.

## More Information

<!-- CMDS: noheader firstseconly noeditbtn -->
```{include} software_linux_docs_iio_iio_snippets_SUB_iio_pointers.md
```
