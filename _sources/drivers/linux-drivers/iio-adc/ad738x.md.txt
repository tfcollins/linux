---
wiki-source: https://wiki.analog.com/resources/tools-software/linux-drivers/iio-adc/ad738x
title: AD7388: 4-Channel, 4 MSPS, 12-Bit, Dual, Simultaneous Sampling SAR ADCs
---

AD738x IIO Dual Channel Serial ADC Linux Driver
===============================================

Supported Devices
-----------------

-   [AD7380](https://www.google.com/search?q=AD7380&btnI=lucky)
-   [AD7381](https://www.google.com/search?q=AD7381&btnI=lucky)
-   [AD7386](https://www.google.com/search?q=AD7386&btnI=lucky)
-   [AD7387](https://www.google.com/search?q=AD7387&btnI=lucky)
-   [AD7388](https://www.google.com/search?q=AD7388&btnI=lucky)

Evaluation Boards
-----------------

-   [EVAL-AD738xFMCZ](https://www.google.com/search?q=EVAL-AD738xFMCZ&btnI=lucky)

Description
-----------

This is a Linux industrial I/O ([IIO](/software/linux/docs/iio/iio)) subsystem driver, targeting dual or quad channel serial interface ADCs.
The industrial I/O subsystem provides a unified framework for drivers for many different types of converters and sensors using a number of different physical interfaces (i2c, spi, etc).
See [IIO](/software/linux/docs/iio/iio) for more information.

Source Code
===========

Status
------

<table>
<thead>
<tr class="header">
<th>Source</th>
<th>Mainlined?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://github.com/analogdevicesinc/linux/blob/master/drivers/iio/adc/ad738x.c">git</a></td>
<td>[No]</td>
</tr>
</tbody>
</table>

Files
-----

<table>
<thead>
<tr class="header">
<th>Function</th>
<th>File</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>driver</td>
<td><a href="https://github.com/analogdevicesinc/linux/blob/master/drivers/iio/adc/ad738x.c">https://github.com/analogdevicesinc/linux/blob/master/drivers/iio/adc/ad738x.c</a></td>
</tr>
</tbody>
</table>

Devicetree
----------

Required devicetree properties:

-   compatible: Needs to be the name of the device. E.g. \"ad7380\"
-   reg: The chipselect number used for the device
-   spi-max-frequency: Maximum SPI clock frequency.
-   spi-cpol: Needs to be set for the correct SPI mode
-   vref-supply: Phandle to the fixed regulator

```{=markdown}
```
        adc_vref: fixedregulator@0 {
            compatible = "regulator-fixed";
        regulator-name = "fixed-supply";
        regulator-min-microvolt = <2500000>;
        regulator-max-microvolt = <2500000>;
        regulator-boot-on;
    };

    #address-cells = <1>;
    #size-cells = <0>;
    status = "okay";

    ad738x@0 {
        compatible = "ad7380";
        reg = <0>;
        spi-max-frequency = <1000000>;
        spi-cpol;
        vref-supply = <&adc_vref>;
    };

```
```
Driver testing
==============

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root:/\> **cd /sys/bus/iio/devices/**
root:/sys/bus/iio/devices\> ls
iio:device0

root:/sys/bus/iio/devices\> **cd iio\\:device0**

root:/sys/bus/iio/devices/iio:device0\> **ls -l**
drwxr-xr-x 2 root root 0 Sep 12 20:11 buffer
-r\--r\--r\-- 1 root root 4096 Sep 12 20:11 dev
-rw-r\--r\-- 1 root root 4096 Sep 12 20:11 in\_voltage0\_raw
-rw-r\--r\-- 1 root root 4096 Sep 12 20:11 in\_voltage1\_raw
-rw-r\--r\-- 1 root root 4096 Sep 12 20:11 in\_voltage\_scale
-r\--r\--r\-- 1 root root 4096 Sep 12 20:11 name
lrwxrwxrwx 1 root root 0 Sep 12 20:11 of\_node -\> ../../../../../../../../firmware/devicetree/base/soc/spi\@7e204000/ad738x\@0
drwxr-xr-x 2 root root 0 Sep 12 20:11 power
drwxr-xr-x 2 root root 0 Sep 12 20:11 scan\_elements
lrwxrwxrwx 1 root root 0 Sep 12 20:11 subsystem -\> ../../../../../../../../bus/iio
drwxr-xr-x 2 root root 0 Sep 12 20:11 trigger
-rw-r\--r\-- 1 root root 4096 Sep 12 20:11 uevent
```
:::


# Show device name

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root:/sys/bus/iio/devices/iio:device0\> **cat name**
ad7380
```
:::


##### Show scale

**Description:**\
scale to be applied to in\_voltage0\_raw in order to obtain the measured voltage in millivolts.

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root:/sys/bus/iio/devices/iio:device0\> **cat in\_voltage\_scale**
0.076293945
```
:::


##### Show channel 0 measurement

**Description:**\
Raw unscaled voltage measurement on channel 0

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root:/sys/bus/iio/devices/iio:device0\> **cat in\_voltage0\_raw**
28583
```
:::


**U** = *in\_voltage0\_raw \* in\_voltage\_scale* = 28583 \* 0.076293945 = **2180.70 *mV***

Trigger management
------------------

If deviceX supports triggered sampling, it's a so called trigger consumer and there will be an additional folder /sys/bus/iio/device/iio:deviceX/trigger. In this folder there is a file called current\_trigger, allowing controlling and viewing the current trigger source connected to deviceX. Available trigger sources can be identified by reading the name file /sys/bus/iio/devices/triggerY/name. The same trigger source can connect to multiple devices, so a single trigger may initialize data capture or reading from a number of sensors, converters, etc.

This driver uses **high resolution timers** as interrupt source

**Description:**\
Hrtimer triggers creation and destruction

Loading iio-trig-hrtimer module will register hrtimer trigger types allowing users to create hrtimer triggers:

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root:/sys/kernel/config/iio/triggers/hrtimer/\> **mkdir trigger0**
```
:::


**Description:**\
Read name of trigger0

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root:/sys/bus/iio/devices/trigger0/\> **cat name**
trigger0
```
:::


**Description:**\
Configure the sampling frequency of trigger0

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root:/sys/bus/iio/devices/trigger0/\> **echo 500 \> sampling\_frequency**
trigger0
```
:::


**Description:**\
Make trigger0 to current trigger of device0

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root:/sys/bus/iio/devices/iio:device0/\> \*\*echo trigger0 \> trigger/current\_trigger \*\*
```
:::


**Description:**\
Read current trigger source of device0

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root:/sys/bus/iio/devices/iio:device0/trigger\> **cat current\_trigger**
trigger0
```
:::


Buffer management
-----------------

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root:/sys/bus/iio/devices/iio:device0/buffer\> ls
**enable** **length** **watermark**
root:/sys/bus/iio/devices/iio:device0/buffer\>
```
:::


Every buffer implementation features a set of files:

**length**\
Get/set the number of sample sets that may be held by the buffer.

**enable**\
Enables/disables the buffer. This file should be written last, after length and selection of scan elements

**scan\_elements**\
The scan\_elements directory contains interfaces for elements that will be captured for a single triggered sample set in the buffer.

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root:/sys/bus/iio/devices/iio:device0/scan\_elements\> ls
in\_voltage0\_en in\_voltage0\_index in\_voltage0\_type in\_voltage1\_en in\_voltage1\_index in\_voltage1\_type
root:/sys/bus/iio/devices/iio:device0/scan\_elements\>
```
:::


**in\_voltageX\_en / in\_voltageX-voltageY\_en / timestamp\_en:**\
Scan element control for triggered data capture. Writing 1 will enable the scan element, writing 0 will disable it

**in\_voltageX\_type / in\_voltageX-voltageY\_type / timestamp\_type:**\
Description of the scan element data storage within the buffer and therefore in the form in which it is read from user-space. Form is \[s|u\]bits/storage-bits. s or u specifies if signed (2\'s complement) or unsigned. bits is the number of bits of data and storage-bits is the space (after padding) that it occupies in the buffer. Note that some devices will have additional information in the unused bits so to get a clean value, the bits value must be used to mask the buffer output value appropriately. The storage-bits value also specifies the data alignment. So u12/16 will be a unsigned 12 bit integer stored in a 16 bit location aligned to a 16 bit boundary. For other storage combinations this attribute will be extended appropriately.

**in\_voltageX\_index / in\_voltageX-voltageY\_index / timestamp\_index:**\
A single positive integer specifying the position of this scan element in the buffer. Note these are not dependent on what is enabled and may not be contiguous. Thus for user-space to establish the full layout these must be used in conjunction with all \_en attributes to establish which channels are present, and the relevant \_type attributes to establish the data storage format.

More Information
================

![iio\_snippets\#iio pointers&noheader&firstseconly&noeditbtn](/page>software/linux/docs/iio/iio_snippets#iio pointers&noheader&firstseconly&noeditbtn)
