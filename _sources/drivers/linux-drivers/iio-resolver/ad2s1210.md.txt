---
wiki-source: https://wiki.analog.com/resources/tools-software/linux-drivers/iio-resolver/ad2s1210
title: AD2S1210: Variable Resolution, 10-Bit to 16-Bit R/D Converter with Reference Oscillator
---

AD2S1210 IIO Resolver-to-Digital Converter Linux Driver
=======================================================

Supported Devices
-----------------

-   [AD2S1210](https://www.google.com/search?q=AD2S1210&btnI=lucky)

Evaluation Boards
-----------------

-   [EVAL-AD2S1210SDZ](https://www.google.com/search?q=EVAL-AD2S1210SDZ&btnI=lucky)

Reference Circuits
------------------

-   [CN0192](https://www.google.com/search?q=CN0192&btnI=lucky)
-   [CN0276](https://www.google.com/search?q=CN0276&btnI=lucky)
-   [CN0317](https://www.google.com/search?q=CN0317&btnI=lucky)

Description
-----------

-   [Product Page](https://www.google.com/search?q=ad2s1200&btnI=lucky)

This is a Linux industrial I/O ([IIO](/software/linux/docs/iio/iio)) subsystem driver, targeting Resolver-to-Digital Converters.
The industrial I/O subsystem provides a unified framework for drivers for many different types of converters and sensors using a number of different physical interfaces (i2c, spi, etc).
See [IIO](/software/linux/docs/iio/iio) for more information.

Source Code
===========

Status
------

<table>
<thead>
<tr class="header">
<th>Source</th>
<th>Mainlined?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/iio/resolver/ad2s1210.c">git</a></td>
<td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/iio/resolver/ad2s1210.c?id=HEAD">Yes</a></td>
</tr>
</tbody>
</table>

Support for the AD2S1210 is in mainline for kernel v6.7 and is backported to v6.1 of the [ADI tree](https://www.google.com/search?q=linux&btnI=lucky). Some additional features are slated for v6.8. The device was previously supported by a staging driver with a different ABI.

Files
-----

<table>
<thead>
<tr class="header">
<th>Function</th>
<th>File</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>driver</td>
<td><a href="https://www.google.com/search?q=drivers/iio/resolver/ad2s1210.c&amp;btnI=lucky">drivers/iio/resolver/ad2s1210.c</a></td>
</tr>
<tr class="even">
<td>devicetree</td>
<td><a href="https://www.google.com/search?q=Documentation/devicetree/bindings/iio/resolver/adi,ad2s1210.yaml&amp;btnI=lucky">Documentation/devicetree/bindings/iio/resolver/adi,ad2s1210.yaml</a></td>
</tr>
</tbody>
</table>

Adding Linux driver support
===========================

Configure kernel with \"make menuconfig\" (alternatively use \"make xconfig\" or
\"make qconfig\")

:::{NOTE} <!-- ATTRS: round="" help\="" -->

The Driver depends on **CONFIG\_SPI**

:::


```{=markdown}
```
Linux Kernel Configuration
    Device Drivers  --->
        [*] Staging drivers  --->
            <*>     Industrial I/O support --->
                --- Industrial I/O support
                -*-   Enable ring buffer support within IIO
                -*-     Industrial I/O lock free software ring
                -*-   Enable triggered sampling support

                      *** Resolver to digital converters ***
                [--snip--]

                <*>   Analog Devices AD2S1210 driver

                [--snip--]


```
```
Driver Usage
============

To configure the chip, use the attributes according to the device register to IIO ABI mapping below:

<table>
<thead>
<tr class="header">
<th>Register</th>
<th>Addr</th>
<th>IIO ABI (sysfs)</th>
<th>Units</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DOS Overrange Threshold</td>
<td>0x89</td>
<td>events/in_altvoltage0_thresh_rising_value</td>
<td>mV</td>
<td></td>
</tr>
<tr class="even">
<td>DOS Mismatch Threshold</td>
<td>0x8A</td>
<td>events/in_altvoltage0_mag_rising_value</td>
<td>mV</td>
<td></td>
</tr>
<tr class="odd">
<td>DOS Reset Maximum Threshold</td>
<td>0x8B</td>
<td>events/in_altvoltage0_mag_rising_reset_max</td>
<td>mV</td>
<td></td>
</tr>
<tr class="even">
<td>DOS Reset Minimum Threshold</td>
<td>0x8C</td>
<td>events/in_altvoltage0_mag_rising_reset_min</td>
<td>mV</td>
<td></td>
</tr>
<tr class="odd">
<td>LOT High Threshold</td>
<td>0x8D</td>
<td>events/in_angl1_thresh_rising_value</td>
<td>Radians</td>
<td></td>
</tr>
<tr class="even">
<td>LOT Low Threshold</td>
<td>0x8E</td>
<td>events/in_angl1_thresh_rising_hysteresis</td>
<td>Radians</td>
<td>The value written to the LOT low register is high value minus the hysteresis.</td>
</tr>
<tr class="odd">
<td>Excitation Frequency</td>
<td>0x91</td>
<td>out_altvoltage0_frequency</td>
<td>Hz</td>
<td></td>
</tr>
<tr class="even">
<td>Control</td>
<td>0x92</td>
<td>*as bit fields*</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Phase lock range</td>
<td>D5</td>
<td>events/in_phase0_mag_rising_value</td>
<td>Radians</td>
<td></td>
</tr>
<tr class="even">
<td>Hysteresis</td>
<td>D4</td>
<td>in_angl0_hysteresis</td>
<td></td>
<td>Convert to radians by multiplying channel scale</td>
</tr>
<tr class="odd">
<td>Encoder resolution</td>
<td>D3:2</td>
<td>*not implemented*</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Resolution</td>
<td>D1:0</td>
<td>*device tree: assigned-resolution-bits*</td>
<td>Bits</td>
<td>10, 12, 14, or 16</td>
</tr>
<tr class="odd">
<td>Soft Reset</td>
<td>0xF0</td>
<td></td>
<td></td>
<td>Soft reset is performed when `out_altvoltage0_frequency` is written.</td>
</tr>
<tr class="even">
<td>Fault</td>
<td>0xFF</td>
<td>*not implemented*</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

Interfacing With the AD2S1210 via iio\_attr
-------------------------------------------

Accessing a list of channels:

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
analog\@setup-2-zed:\~ \$ iio\_attr ad2s1210 -c
dev \'ad2s1210\', channel \'angl0\' (input, index: 0, format: be:U16/16\>\>0), found 5 channel-specific attributes
dev \'ad2s1210\', channel \'anglvel0\' (input, index: 1, format: be:S16/16\>\>0), found 3 channel-specific attributes
dev \'ad2s1210\', channel \'timestamp\' (input, index: 2, format: le:S64/64\>\>0), found 0 channel-specific attributes
dev \'ad2s1210\', channel \'phase0\' (input), found 1 channel-specific attributes
dev \'ad2s1210\', channel \'altvoltage0\' (output), found 3 channel-specific attributes
dev \'ad2s1210\', channel \'altvoltage2\' (input), found 1 channel-specific attributes
dev \'ad2s1210\', channel \'angl1\' (input), found 1 channel-specific attributes
dev \'ad2s1210\', channel \'altvoltage0\' (input), found 1 channel-specific attributes
dev \'ad2s1210\', channel \'altvoltage1\' (input), found 1 channel-specific attributes
```
:::


For example, to get position channel **angl0**:
:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
analog\@setup-2-zed:\~ \$ iio\_attr ad2s1210 -ci angl0
dev \'ad2s1210\', channel \'angl0\' (input), attr \'hysteresis\', value \'1\'
dev \'ad2s1210\', channel \'angl0\' (input), attr \'hysteresis\_available\', value \'0 1\'
dev \'ad2s1210\', channel \'angl0\' (input), attr \'label\', value \'position\'
dev \'ad2s1210\', channel \'angl0\' (input), attr \'raw\', value \'34114\'
dev \'ad2s1210\', channel \'angl0\' (input), attr \'scale\', value \'0.000095874\'
```
:::


Or velocity channel **anglvel0**:

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
analog\@setup-2-zed:\~ \$ iio\_attr ad2s1210 -ci anglvel0
dev \'ad2s1210\', channel \'anglvel0\' (input), attr \'label\', value \'velocity\'
dev \'ad2s1210\', channel \'anglvel0\' (input), attr \'raw\', value \'0\'
dev \'ad2s1210\', channel \'anglvel0\' (input), attr \'scale\', value \'0.023968449\'
```
:::


Interfacing With the AD2S1210 via /sys/bus
------------------------------------------

Alternatively, you can read and write data directly from the device path in /sys/bus:

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
analog\@setup-2-zed:\~ \$ cd /sys/bus/iio/devices/iio\\:device1/

analog\@setup-2-zed:/sys/bus/iio/devices/iio:device1 \$ tree
.
├── buffer
│   ├── data\_available
│   ├── direction
│   ├── enable
│   ├── length
│   └── watermark
├── buffer0
│   ├── data\_available
│   ├── direction
│   ├── enable
│   ├── in\_angl0\_en
│   ├── in\_angl0\_index
│   ├── in\_angl0\_type
│   ├── in\_anglvel0\_en
│   ├── in\_anglvel0\_index
│   ├── in\_anglvel0\_type
│   ├── in\_timestamp\_en
│   ├── in\_timestamp\_index
│   ├── in\_timestamp\_type
│   ├── length
│   └── watermark
├── current\_timestamp\_clock
├── dev
├── events
│   ├── in\_altvoltage0\_mag\_rising\_label
│   ├── in\_altvoltage0\_mag\_rising\_reset\_max
│   ├── in\_altvoltage0\_mag\_rising\_reset\_max\_available
│   ├── in\_altvoltage0\_mag\_rising\_reset\_min
│   ├── in\_altvoltage0\_mag\_rising\_reset\_min\_available
│   ├── in\_altvoltage0\_mag\_rising\_value
│   ├── in\_altvoltage0\_mag\_rising\_value\_available
│   ├── in\_altvoltage0\_thresh\_falling\_label
│   ├── in\_altvoltage0\_thresh\_falling\_value
│   ├── in\_altvoltage0\_thresh\_falling\_value\_available
│   ├── in\_altvoltage0\_thresh\_rising\_label
│   ├── in\_altvoltage0\_thresh\_rising\_value
│   ├── in\_altvoltage0\_thresh\_rising\_value\_available
│   ├── in\_altvoltage1\_mag\_either\_label
│   ├── in\_altvoltage2\_mag\_either\_label
│   ├── in\_angl1\_thresh\_rising\_hysteresis
│   ├── in\_angl1\_thresh\_rising\_hysteresis\_available
│   ├── in\_angl1\_thresh\_rising\_label
│   ├── in\_angl1\_thresh\_rising\_value
│   ├── in\_angl1\_thresh\_rising\_value\_available
│   ├── in\_anglvel0\_mag\_rising\_label
│   ├── in\_phase0\_mag\_rising\_label
│   ├── in\_phase0\_mag\_rising\_value
│   └── in\_phase0\_mag\_rising\_value\_available
├── in\_altvoltage0\_label
├── in\_altvoltage1\_label
├── in\_altvoltage2\_label
├── in\_angl0\_hysteresis
├── in\_angl0\_hysteresis\_available
├── in\_angl0\_label
├── in\_angl0\_raw
├── in\_angl0\_scale
├── in\_angl1\_label
├── in\_anglvel0\_label
├── in\_anglvel0\_raw
├── in\_anglvel0\_scale
├── in\_phase0\_label
├── name
├── of\_node -\> ../../../../../../../../firmware/devicetree/base/axi/spi\@e0006000/ad2s1210\@0
├── out\_altvoltage0\_frequency
├── out\_altvoltage0\_frequency\_available
├── out\_altvoltage0\_label
├── power
│   ├── autosuspend\_delay\_ms
│   ├── control
│   ├── runtime\_active\_time
│   ├── runtime\_status
│   └── runtime\_suspended\_time
├── scan\_elements
│   ├── in\_angl0\_en
│   ├── in\_angl0\_index
│   ├── in\_angl0\_type
│   ├── in\_anglvel0\_en
│   ├── in\_anglvel0\_index
│   ├── in\_anglvel0\_type
│   ├── in\_timestamp\_en
│   ├── in\_timestamp\_index
│   └── in\_timestamp\_type
├── subsystem -\> ../../../../../../../../bus/iio
├── trigger
│   └── current\_trigger
├── uevent
└── waiting\_for\_supplier

analog\@setup-2-zed:/sys/bus/iio/devices/iio:device1 \$ cat name
ad2s1210

analog\@setup-2-zed:/sys/bus/iio/devices/iio:device1 \$ cat in\_angl0\_raw
34115
```
:::


Hysteresis can be enabled or disabled this way. To do so, first check the output of in\_angl0\_hysteresis\_available:

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root\@setup-2-zed:/sys/bus/iio/devices/iio:device1\# cat in\_angl0\_hysteresis\_available
0 1
```
:::


To turn hysteresis off, write the first value from the output to in\_angl0\_hysteresis:

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root\@setup-2-zed:/sys/bus/iio/devices/iio:device1\# echo 0 \> in\_angl0\_hysteresis
```
:::


To turn it on, write the second value (which is dependent on the assigned bits for resolution and may not always be 1):

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root\@setup-2-zed:/sys/bus/iio/devices/iio:device1\# echo 1 \> in\_angl0\_hysteresis
```
:::


Triggered buffer
----------------

To generate samples using the triggered buffer, you will need a trigger. You can create an hrtimer trigger and test it by retrieving samples like this:

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root\@setup-2-zed:\~\# mkdir /sys/kernel/config/iio/triggers/hrtimer/test
root\@setup-2-zed:\~\# iio\_readdev ad2s1210 -t test -s 1000 -T 10000 | hd
WARNING: High-speed mode not enabled
00000000 85 41 00 00 00 00 00 00 82 e1 7d ad 09 54 9e 17 |.A\...\.....}..T..|
00000010 85 41 00 00 00 00 00 00 00 70 16 ae 09 54 9e 17 |.A\...\....p\...T..|
00000020 85 42 00 00 00 00 00 00 5f 06 af ae 09 54 9e 17 |.B\...\...\_\....T..|
00000030 85 41 00 00 00 00 00 00 3f a2 47 af 09 54 9e 17 |.A\...\...?.G..T..|
00000040 85 42 00 00 00 00 00 00 7f 32 e0 af 09 54 9e 17 |.B\...\....2\...T..|
00000050 85 41 00 00 00 00 00 00 41 c8 78 b0 09 54 9e 17 |.A\...\...A.x..T..|
00000060 85 41 00 00 00 00 00 00 ab 64 11 b1 09 54 9e 17 |.A\...\....d\...T..|
00000070 85 41 00 00 00 00 00 00 fb f6 a9 b1 09 54 9e 17 |.A\...\...\.....T..|
00000080 85 41 00 00 00 00 00 00 85 8b 42 b2 09 54 9e 17 |.A\...\.....B..T..|
00000090 85 41 ff ff 00 00 00 00 13 22 db b2 09 54 9e 17 |.A\...\....\"\...T..|
000000a0 85 42 00 00 00 00 00 00 e3 b8 73 b3 09 54 9e 17 |.B\...\.....s..T..|
000000b0 85 42 00 00 00 00 00 00 53 4f 0c b4 09 54 9e 17 |.B\...\...SO\...T..|
000000c0 85 41 00 00 00 00 00 00 6a e8 a4 b4 09 54 9e 17 |.A\...\...j\....T..|
000000d0 85 41 00 00 00 00 00 00 24 7d 3d b5 09 54 9e 17 |.A\...\...\$}=..T..|
000000e0 85 41 ff ff 00 00 00 00 7c 13 d6 b5 09 54 9e 17 |.A\...\...|\....T..|
000000f0 85 41 00 00 00 00 00 00 2c a9 6e b6 09 54 9e 17 |.A\...\...,.n..T..|
\...
```
:::


\<note important\> using the -t option to specify the trigger with iio\_readdev resets the sampling rate of the hrtimer trigger back to 100Hz!\</note\>

For other apps, we probably want a high sample rate. You can change the rate like this:

:::{NOTE} <!-- ATTRS: box="" bggreen\="" -->
:::{HINT} <!-- ATTRS: info\="" -->
This specifies any shell prompt running on the target
:::

```bash
root\@setup-2-zed:\~\# iio\_attr -d test sampling\_frequency 10000
10000.000000
```
:::


Reading IIO Events
------------------

See [iio\_event\_monitor](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/iio/iio_event_monitor.c) for an example of a program designed to read IIO events.

Fault to event mapping:

<table>
<thead>
<tr class="header">
<th>Fault</th>
<th></th>
<th>Channel</th>
<th>Type</th>
<th>Direction</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Sine/cosine inputs clipped</td>
<td>D7</td>
<td>altvoltage1</td>
<td>mag</td>
<td>either</td>
<td>The chip does not differentiate between fault on sine vs. cosine so there will also be an event on the altvoltage2 channel.</td>
</tr>
<tr class="even">
<td>Sine/cosine inputs below LOS</td>
<td>D6</td>
<td>altvoltage0</td>
<td>thresh</td>
<td>falling</td>
<td></td>
</tr>
<tr class="odd">
<td>Sine/cosine inputs exceed DOS overrange</td>
<td>D5</td>
<td>altvoltage0</td>
<td>thresh</td>
<td>rising</td>
<td></td>
</tr>
<tr class="even">
<td>Sine/cosine inputs exceed DOS mismatch</td>
<td>D4</td>
<td>altvoltage0</td>
<td>mag</td>
<td>rising</td>
<td></td>
</tr>
<tr class="odd">
<td>Tracking error exceeds LOT</td>
<td>D3</td>
<td>angl1</td>
<td>thresh</td>
<td>rising</td>
<td></td>
</tr>
<tr class="even">
<td>Velocity exceeds maximum tracking rate</td>
<td>D2</td>
<td>anglvel0</td>
<td>mag</td>
<td>rising</td>
<td></td>
</tr>
<tr class="odd">
<td>Phase error exceeds phase lock range</td>
<td>D1</td>
<td>phase0</td>
<td>mag</td>
<td>rising</td>
<td></td>
</tr>
<tr class="even">
<td>Configuration parity error</td>
<td>D0</td>
<td>*writes to kernel log*</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

Usage With the EVAL-AD2S1210SDZ Evaluation Board
================================================

Interfacing With a Raspberry Pi
-------------------------------

# Wiring

<table>
<thead>
<tr class="header">
<th>AD2S1210 Pin</th>
<th>Eval Board Pin</th>
<th>RPi Header Pin</th>
<th>RPi Function</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RES0</td>
<td>LK6</td>
<td>15</td>
<td>GPIO22</td>
<td>There aren’t J4 pins for RES0/1 so have to use jumper pins. It is also possible to hard-wire resolution pins RES0/1, but device tree would need to be changed accordingly.</td>
</tr>
<tr class="even">
<td>RES1</td>
<td>LK7</td>
<td>16</td>
<td>GPIO23</td>
<td>There aren’t J4 pins for RES0/1 so have to use jumper pins. It is also possible to hard-wire resolution pins RES0/1, but device tree would need to be changed accordingly.</td>
</tr>
<tr class="odd">
<td>A0</td>
<td>J4-12</td>
<td>18</td>
<td>GPIO24</td>
<td></td>
</tr>
<tr class="even">
<td>A1</td>
<td>J4-11</td>
<td>22</td>
<td>GPIO25</td>
<td></td>
</tr>
<tr class="odd">
<td>WR/FSYNC</td>
<td>J4-4</td>
<td>24</td>
<td>SPI0 CE0</td>
<td></td>
</tr>
<tr class="even">
<td>SAMPLE</td>
<td>J4-1</td>
<td>12</td>
<td>GPIO18</td>
<td></td>
</tr>
<tr class="odd">
<td>VDRIVE</td>
<td>J704-1</td>
<td>1</td>
<td>3.3V</td>
<td></td>
</tr>
<tr class="even">
<td>DGND</td>
<td>J704-2</td>
<td>9</td>
<td>GND</td>
<td></td>
</tr>
<tr class="odd">
<td>SCLK</td>
<td>J4-10</td>
<td>23</td>
<td>SPI0 SCLK</td>
<td></td>
</tr>
<tr class="even">
<td>SDI</td>
<td>J4-9</td>
<td>19</td>
<td>SPI0 MOSI</td>
<td></td>
</tr>
<tr class="odd">
<td>SDO</td>
<td>J4-8</td>
<td>21</td>
<td>SPI0 MISO</td>
<td></td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr class="header">
<th>AD2S1210 Pin</th>
<th>Eval Board Pins (Jumpered)</th>
<th>Eval Board Signal</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RD</td>
<td>J4-3, J4-7</td>
<td>VDRIVE</td>
</tr>
<tr class="even">
<td>CS</td>
<td>J4-2, J4-6</td>
<td>DGND</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr class="header">
<th>Eval Board Signal</th>
<th>Eval Board Jumper</th>
<th>Position</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SAMPLE</td>
<td>LK1</td>
<td>B</td>
<td></td>
</tr>
<tr class="even">
<td>CS</td>
<td>LK2</td>
<td>C</td>
<td></td>
</tr>
<tr class="odd">
<td>RD</td>
<td>LK3</td>
<td>C</td>
<td></td>
</tr>
<tr class="even">
<td>A0</td>
<td>LK 4</td>
<td>C</td>
<td></td>
</tr>
<tr class="odd">
<td>A1</td>
<td>LK5</td>
<td>C</td>
<td></td>
</tr>
<tr class="even">
<td>RES0</td>
<td>LK6</td>
<td>C</td>
<td>There aren’t J4 pins for RES0/1 so have to use jumper pins. It is also possible to hard-wire resolution pins RES0/1, but device tree would need to be changed accordingly.</td>
</tr>
<tr class="odd">
<td>RES1</td>
<td>LK7</td>
<td>C</td>
<td>There aren’t J4 pins for RES0/1 so have to use jumper pins. It is also possible to hard-wire resolution pins RES0/1, but device tree would need to be changed accordingly.</td>
</tr>
<tr class="even">
<td>SOE</td>
<td>LK9</td>
<td>B</td>
<td></td>
</tr>
<tr class="odd">
<td>VDRIVE</td>
<td>LK703</td>
<td>B</td>
<td></td>
</tr>
</tbody>
</table>

#### Device Tree

Add `dtoverlay=ad2s1210` to `/boot/config.txt`.

Overlay: [ad2s1210-overlay.dts](https://raw.githubusercontent.com/analogdevicesinc/linux/rpi-6.1.y/arch/arm/boot/dts/overlays/ad2s1210-overlay.dts)

#### Sample Images

Eval board connections:

![](/resources/tools-software/linux-drivers/iio-resolver/img_20231206_135017785_hdr.jpg){width="400"}

Raspberry Pi connections:

![](/resources/tools-software/linux-drivers/iio-resolver/img_20231206_135039086.jpg){width="400"}

Zedboard
--------

![](/resources/tools-software/linux-drivers/iio-resolver/img_20231207_080341.jpg){width="400"}

See [ad2s1210\_sdz](/resources/eval/user-guides/ad2s1210_sdz) for a detailed setup guide

More Information
================

![iio\_snippets\#iio pointers&noheader&firstseconly&noeditbtn](/page>software/linux/docs/iio/iio_snippets#iio pointers&noheader&firstseconly&noeditbtn)
