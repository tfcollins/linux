---
wiki-source: https://wiki.analog.com/resources/tools-software/linux-drivers/iio-resolver/ad2s1210
title: AD2S1210: Variable Resolution, 10-Bit to 16-Bit R/D Converter with Reference Oscillator
---

AD2S1210 IIO Resolver-to-Digital Converter Linux Driver
=======================================================

# Supported Devices

-   [AD2S1210](https://www.google.com/search?q=AD2S1210&btnI=lucky)

#### Evaluation Boards

-   [EVAL-AD2S1210SDZ](https://www.google.com/search?q=EVAL-AD2S1210SDZ&btnI=lucky)

#### Reference Circuits

-   [CN0192](https://www.google.com/search?q=CN0192&btnI=lucky)
-   [CN0276](https://www.google.com/search?q=CN0276&btnI=lucky)
-   [CN0317](https://www.google.com/search?q=CN0317&btnI=lucky)

#### Description

-   [Product Page](https://www.google.com/search?q=ad2s1200&btnI=lucky)

This is a Linux industrial I/O ([IIO](/software/linux/docs/iio/iio)) subsystem driver, targeting Resolver-to-Digital Converters.
The industrial I/O subsystem provides a unified framework for drivers for many different types of converters and sensors using a number of different physical interfaces (i2c, spi, etc).
See [IIO](/software/linux/docs/iio/iio) for more information.

Source Code
-----------

#### Status

<table>
<thead>
<tr class="header">
<th>Source</th>
<th>Mainlined?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/iio/resolver/ad2s1210.c">git</a></td>
<td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/iio/resolver/ad2s1210.c?id=HEAD">Yes</a></td>
</tr>
</tbody>
</table>

Support for the AD2S1210 is in mainline for kernel v6.7 and is backported to v6.1 of the [ADI tree](https://www.google.com/search?q=linux&btnI=lucky). Some additional features are slated for v6.8. The device was previously supported by a staging driver with a different ABI.

#### Files

<table>
<thead>
<tr class="header">
<th>Function</th>
<th>File</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>driver</td>
<td><a href="https://www.google.com/search?q=drivers/iio/resolver/ad2s1210.c&amp;btnI=lucky">drivers/iio/resolver/ad2s1210.c</a></td>
</tr>
<tr class="even">
<td>devicetree</td>
<td><a href="https://www.google.com/search?q=Documentation/devicetree/bindings/iio/resolver/adi,ad2s1210.yaml&amp;btnI=lucky">Documentation/devicetree/bindings/iio/resolver/adi,ad2s1210.yaml</a></td>
</tr>
</tbody>
</table>

Adding Linux driver support
---------------------------

Configure kernel with "make menuconfig" (alternatively use "make xconfig" or
"make qconfig")

:::{NOTE} <!-- ATTRS: round="" help="" -->

The Driver depends on **CONFIG_SPI**

:::


    Linux Kernel Configuration
        Device Drivers  --->
            [*] Staging drivers  --->
                <*>     Industrial I/O support --->
                    --- Industrial I/O support
                    -*-   Enable ring buffer support within IIO
                    -*-     Industrial I/O lock free software ring
                    -*-   Enable triggered sampling support

                          *** Resolver to digital converters ***
                    [--snip--]

                    <*>   Analog Devices AD2S1210 driver

                    [--snip--]

Driver Usage
------------

To configure the chip, use the attributes according to the device register to IIO ABI mapping below:

<table>
<thead>
<tr class="header">
<th>Register</th>
<th>Addr</th>
<th>IIO ABI (sysfs)</th>
<th>Units</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DOS Overrange Threshold</td>
<td>0x89</td>
<td>events/in_altvoltage0_thresh_rising_value</td>
<td>mV</td>
<td></td>
</tr>
<tr class="even">
<td>DOS Mismatch Threshold</td>
<td>0x8A</td>
<td>events/in_altvoltage0_mag_rising_value</td>
<td>mV</td>
<td></td>
</tr>
<tr class="odd">
<td>DOS Reset Maximum Threshold</td>
<td>0x8B</td>
<td>events/in_altvoltage0_mag_rising_reset_max</td>
<td>mV</td>
<td></td>
</tr>
<tr class="even">
<td>DOS Reset Minimum Threshold</td>
<td>0x8C</td>
<td>events/in_altvoltage0_mag_rising_reset_min</td>
<td>mV</td>
<td></td>
</tr>
<tr class="odd">
<td>LOT High Threshold</td>
<td>0x8D</td>
<td>events/in_angl1_thresh_rising_value</td>
<td>Radians</td>
<td></td>
</tr>
<tr class="even">
<td>LOT Low Threshold</td>
<td>0x8E</td>
<td>events/in_angl1_thresh_rising_hysteresis</td>
<td>Radians</td>
<td>The value written to the LOT low register is high value minus the hysteresis.</td>
</tr>
<tr class="odd">
<td>Excitation Frequency</td>
<td>0x91</td>
<td>out_altvoltage0_frequency</td>
<td>Hz</td>
<td></td>
</tr>
<tr class="even">
<td>Control</td>
<td>0x92</td>
<td>*as bit fields*</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Phase lock range</td>
<td>D5</td>
<td>events/in_phase0_mag_rising_value</td>
<td>Radians</td>
<td></td>
</tr>
<tr class="even">
<td>Hysteresis</td>
<td>D4</td>
<td>in_angl0_hysteresis</td>
<td></td>
<td>Convert to radians by multiplying channel scale</td>
</tr>
<tr class="odd">
<td>Encoder resolution</td>
<td>D3:2</td>
<td>*not implemented*</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Resolution</td>
<td>D1:0</td>
<td>*device tree: assigned-resolution-bits*</td>
<td>Bits</td>
<td>10, 12, 14, or 16</td>
</tr>
<tr class="odd">
<td>Soft Reset</td>
<td>0xF0</td>
<td></td>
<td></td>
<td>Soft reset is performed when `out_altvoltage0_frequency` is written.</td>
</tr>
<tr class="even">
<td>Fault</td>
<td>0xFF</td>
<td>*not implemented*</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

#### Interfacing With the AD2S1210 via iio_attr

Accessing a list of channels:

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```bash
analog@setup-2-zed:~ $ iio_attr ad2s1210 -c
dev 'ad2s1210', channel 'angl0' (input, index: 0, format: be:U16/16>>0), found 5 channel-specific attributes
dev 'ad2s1210', channel 'anglvel0' (input, index: 1, format: be:S16/16>>0), found 3 channel-specific attributes
dev 'ad2s1210', channel 'timestamp' (input, index: 2, format: le:S64/64>>0), found 0 channel-specific attributes
dev 'ad2s1210', channel 'phase0' (input), found 1 channel-specific attributes
dev 'ad2s1210', channel 'altvoltage0' (output), found 3 channel-specific attributes
dev 'ad2s1210', channel 'altvoltage2' (input), found 1 channel-specific attributes
dev 'ad2s1210', channel 'angl1' (input), found 1 channel-specific attributes
dev 'ad2s1210', channel 'altvoltage0' (input), found 1 channel-specific attributes
dev 'ad2s1210', channel 'altvoltage1' (input), found 1 channel-specific attributes
```
:::


For example, to get position channel **angl0**:
:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```bash
analog@setup-2-zed:~ $ iio_attr ad2s1210 -ci angl0
dev 'ad2s1210', channel 'angl0' (input), attr 'hysteresis', value '1'
dev 'ad2s1210', channel 'angl0' (input), attr 'hysteresis_available', value '0 1'
dev 'ad2s1210', channel 'angl0' (input), attr 'label', value 'position'
dev 'ad2s1210', channel 'angl0' (input), attr 'raw', value '34114'
dev 'ad2s1210', channel 'angl0' (input), attr 'scale', value '0.000095874'
```
:::


Or velocity channel **anglvel0**:

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```bash
analog@setup-2-zed:~ $ iio_attr ad2s1210 -ci anglvel0
dev 'ad2s1210', channel 'anglvel0' (input), attr 'label', value 'velocity'
dev 'ad2s1210', channel 'anglvel0' (input), attr 'raw', value '0'
dev 'ad2s1210', channel 'anglvel0' (input), attr 'scale', value '0.023968449'
```
:::


#### Interfacing With the AD2S1210 via /sys/bus

Alternatively, you can read and write data directly from the device path in /sys/bus:

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```bash
analog@setup-2-zed:~ $ cd /sys/bus/iio/devices/iio:device1/

analog@setup-2-zed:/sys/bus/iio/devices/iio:device1 $ tree
.
├── buffer
│   ├── data_available
│   ├── direction
│   ├── enable
│   ├── length
│   └── watermark
├── buffer0
│   ├── data_available
│   ├── direction
│   ├── enable
│   ├── in_angl0_en
│   ├── in_angl0_index
│   ├── in_angl0_type
│   ├── in_anglvel0_en
│   ├── in_anglvel0_index
│   ├── in_anglvel0_type
│   ├── in_timestamp_en
│   ├── in_timestamp_index
│   ├── in_timestamp_type
│   ├── length
│   └── watermark
├── current_timestamp_clock
├── dev
├── events
│   ├── in_altvoltage0_mag_rising_label
│   ├── in_altvoltage0_mag_rising_reset_max
│   ├── in_altvoltage0_mag_rising_reset_max_available
│   ├── in_altvoltage0_mag_rising_reset_min
│   ├── in_altvoltage0_mag_rising_reset_min_available
│   ├── in_altvoltage0_mag_rising_value
│   ├── in_altvoltage0_mag_rising_value_available
│   ├── in_altvoltage0_thresh_falling_label
│   ├── in_altvoltage0_thresh_falling_value
│   ├── in_altvoltage0_thresh_falling_value_available
│   ├── in_altvoltage0_thresh_rising_label
│   ├── in_altvoltage0_thresh_rising_value
│   ├── in_altvoltage0_thresh_rising_value_available
│   ├── in_altvoltage1_mag_either_label
│   ├── in_altvoltage2_mag_either_label
│   ├── in_angl1_thresh_rising_hysteresis
│   ├── in_angl1_thresh_rising_hysteresis_available
│   ├── in_angl1_thresh_rising_label
│   ├── in_angl1_thresh_rising_value
│   ├── in_angl1_thresh_rising_value_available
│   ├── in_anglvel0_mag_rising_label
│   ├── in_phase0_mag_rising_label
│   ├── in_phase0_mag_rising_value
│   └── in_phase0_mag_rising_value_available
├── in_altvoltage0_label
├── in_altvoltage1_label
├── in_altvoltage2_label
├── in_angl0_hysteresis
├── in_angl0_hysteresis_available
├── in_angl0_label
├── in_angl0_raw
├── in_angl0_scale
├── in_angl1_label
├── in_anglvel0_label
├── in_anglvel0_raw
├── in_anglvel0_scale
├── in_phase0_label
├── name
├── of_node -> ../../../../../../../../firmware/devicetree/base/axi/spi@e0006000/ad2s1210@0
├── out_altvoltage0_frequency
├── out_altvoltage0_frequency_available
├── out_altvoltage0_label
├── power
│   ├── autosuspend_delay_ms
│   ├── control
│   ├── runtime_active_time
│   ├── runtime_status
│   └── runtime_suspended_time
├── scan_elements
│   ├── in_angl0_en
│   ├── in_angl0_index
│   ├── in_angl0_type
│   ├── in_anglvel0_en
│   ├── in_anglvel0_index
│   ├── in_anglvel0_type
│   ├── in_timestamp_en
│   ├── in_timestamp_index
│   └── in_timestamp_type
├── subsystem -> ../../../../../../../../bus/iio
├── trigger
│   └── current_trigger
├── uevent
└── waiting_for_supplier

analog@setup-2-zed:/sys/bus/iio/devices/iio:device1 $ cat name
ad2s1210

analog@setup-2-zed:/sys/bus/iio/devices/iio:device1 $ cat in_angl0_raw
34115
```
:::


Hysteresis can be enabled or disabled this way. To do so, first check the output of in_angl0_hysteresis_available:

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```bash
root@setup-2-zed:/sys/bus/iio/devices/iio:device1# cat in_angl0_hysteresis_available
0 1
```
:::


To turn hysteresis off, write the first value from the output to in_angl0_hysteresis:

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```bash
root@setup-2-zed:/sys/bus/iio/devices/iio:device1# echo 0 > in_angl0_hysteresis
```
:::


To turn it on, write the second value (which is dependent on the assigned bits for resolution and may not always be 1):

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```bash
root@setup-2-zed:/sys/bus/iio/devices/iio:device1# echo 1 > in_angl0_hysteresis
```
:::


#### Triggered buffer

To generate samples using the triggered buffer, you will need a trigger. You can create an hrtimer trigger and test it by retrieving samples like this:

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```bash
root@setup-2-zed:~# mkdir /sys/kernel/config/iio/triggers/hrtimer/test
root@setup-2-zed:~# iio_readdev ad2s1210 -t test -s 1000 -T 10000 | hd
WARNING: High-speed mode not enabled
00000000 85 41 00 00 00 00 00 00 82 e1 7d ad 09 54 9e 17 |.A........}..T..|
00000010 85 41 00 00 00 00 00 00 00 70 16 ae 09 54 9e 17 |.A.......p...T..|
00000020 85 42 00 00 00 00 00 00 5f 06 af ae 09 54 9e 17 |.B......_....T..|
00000030 85 41 00 00 00 00 00 00 3f a2 47 af 09 54 9e 17 |.A......?.G..T..|
00000040 85 42 00 00 00 00 00 00 7f 32 e0 af 09 54 9e 17 |.B.......2...T..|
00000050 85 41 00 00 00 00 00 00 41 c8 78 b0 09 54 9e 17 |.A......A.x..T..|
00000060 85 41 00 00 00 00 00 00 ab 64 11 b1 09 54 9e 17 |.A.......d...T..|
00000070 85 41 00 00 00 00 00 00 fb f6 a9 b1 09 54 9e 17 |.A...........T..|
00000080 85 41 00 00 00 00 00 00 85 8b 42 b2 09 54 9e 17 |.A........B..T..|
00000090 85 41 ff ff 00 00 00 00 13 22 db b2 09 54 9e 17 |.A......."...T..|
000000a0 85 42 00 00 00 00 00 00 e3 b8 73 b3 09 54 9e 17 |.B........s..T..|
000000b0 85 42 00 00 00 00 00 00 53 4f 0c b4 09 54 9e 17 |.B......SO...T..|
000000c0 85 41 00 00 00 00 00 00 6a e8 a4 b4 09 54 9e 17 |.A......j....T..|
000000d0 85 41 00 00 00 00 00 00 24 7d 3d b5 09 54 9e 17 |.A......$}=..T..|
000000e0 85 41 ff ff 00 00 00 00 7c 13 d6 b5 09 54 9e 17 |.A......|....T..|
000000f0 85 41 00 00 00 00 00 00 2c a9 6e b6 09 54 9e 17 |.A......,.n..T..|
...
```
:::


<note important> using the -t option to specify the trigger with iio_readdev resets the sampling rate of the hrtimer trigger back to 100Hz!</note>

For other apps, we probably want a high sample rate. You can change the rate like this:

:::{NOTE} <!-- ATTRS: box="" bggreen="" -->
:::{HINT} <!-- ATTRS: info="" -->
This specifies any shell prompt running on the target
:::

```bash
root@setup-2-zed:~# iio_attr -d test sampling_frequency 10000
10000.000000
```
:::


#### Reading IIO Events

See [iio_event_monitor](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/iio/iio_event_monitor.c) for an example of a program designed to read IIO events.

Fault to event mapping:

<table>
<thead>
<tr class="header">
<th>Fault</th>
<th></th>
<th>Channel</th>
<th>Type</th>
<th>Direction</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Sine/cosine inputs clipped</td>
<td>D7</td>
<td>altvoltage1</td>
<td>mag</td>
<td>either</td>
<td>The chip does not differentiate between fault on sine vs. cosine so there will also be an event on the altvoltage2 channel.</td>
</tr>
<tr class="even">
<td>Sine/cosine inputs below LOS</td>
<td>D6</td>
<td>altvoltage0</td>
<td>thresh</td>
<td>falling</td>
<td></td>
</tr>
<tr class="odd">
<td>Sine/cosine inputs exceed DOS overrange</td>
<td>D5</td>
<td>altvoltage0</td>
<td>thresh</td>
<td>rising</td>
<td></td>
</tr>
<tr class="even">
<td>Sine/cosine inputs exceed DOS mismatch</td>
<td>D4</td>
<td>altvoltage0</td>
<td>mag</td>
<td>rising</td>
<td></td>
</tr>
<tr class="odd">
<td>Tracking error exceeds LOT</td>
<td>D3</td>
<td>angl1</td>
<td>thresh</td>
<td>rising</td>
<td></td>
</tr>
<tr class="even">
<td>Velocity exceeds maximum tracking rate</td>
<td>D2</td>
<td>anglvel0</td>
<td>mag</td>
<td>rising</td>
<td></td>
</tr>
<tr class="odd">
<td>Phase error exceeds phase lock range</td>
<td>D1</td>
<td>phase0</td>
<td>mag</td>
<td>rising</td>
<td></td>
</tr>
<tr class="even">
<td>Configuration parity error</td>
<td>D0</td>
<td>*writes to kernel log*</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

Usage With the EVAL-AD2S1210SDZ Evaluation Board
------------------------------------------------

#### Interfacing With a Raspberry Pi

##### Wiring

<table>
<thead>
<tr class="header">
<th>AD2S1210 Pin</th>
<th>Eval Board Pin</th>
<th>RPi Header Pin</th>
<th>RPi Function</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RES0</td>
<td>LK6</td>
<td>15</td>
<td>GPIO22</td>
<td>There aren’t J4 pins for RES0/1 so have to use jumper pins. It is also possible to hard-wire resolution pins RES0/1, but device tree would need to be changed accordingly.</td>
</tr>
<tr class="even">
<td>RES1</td>
<td>LK7</td>
<td>16</td>
<td>GPIO23</td>
<td>There aren’t J4 pins for RES0/1 so have to use jumper pins. It is also possible to hard-wire resolution pins RES0/1, but device tree would need to be changed accordingly.</td>
</tr>
<tr class="odd">
<td>A0</td>
<td>J4-12</td>
<td>18</td>
<td>GPIO24</td>
<td></td>
</tr>
<tr class="even">
<td>A1</td>
<td>J4-11</td>
<td>22</td>
<td>GPIO25</td>
<td></td>
</tr>
<tr class="odd">
<td>WR/FSYNC</td>
<td>J4-4</td>
<td>24</td>
<td>SPI0 CE0</td>
<td></td>
</tr>
<tr class="even">
<td>SAMPLE</td>
<td>J4-1</td>
<td>12</td>
<td>GPIO18</td>
<td></td>
</tr>
<tr class="odd">
<td>VDRIVE</td>
<td>J704-1</td>
<td>1</td>
<td>3.3V</td>
<td></td>
</tr>
<tr class="even">
<td>DGND</td>
<td>J704-2</td>
<td>9</td>
<td>GND</td>
<td></td>
</tr>
<tr class="odd">
<td>SCLK</td>
<td>J4-10</td>
<td>23</td>
<td>SPI0 SCLK</td>
<td></td>
</tr>
<tr class="even">
<td>SDI</td>
<td>J4-9</td>
<td>19</td>
<td>SPI0 MOSI</td>
<td></td>
</tr>
<tr class="odd">
<td>SDO</td>
<td>J4-8</td>
<td>21</td>
<td>SPI0 MISO</td>
<td></td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr class="header">
<th>AD2S1210 Pin</th>
<th>Eval Board Pins (Jumpered)</th>
<th>Eval Board Signal</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RD</td>
<td>J4-3, J4-7</td>
<td>VDRIVE</td>
</tr>
<tr class="even">
<td>CS</td>
<td>J4-2, J4-6</td>
<td>DGND</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr class="header">
<th>Eval Board Signal</th>
<th>Eval Board Jumper</th>
<th>Position</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SAMPLE</td>
<td>LK1</td>
<td>B</td>
<td></td>
</tr>
<tr class="even">
<td>CS</td>
<td>LK2</td>
<td>C</td>
<td></td>
</tr>
<tr class="odd">
<td>RD</td>
<td>LK3</td>
<td>C</td>
<td></td>
</tr>
<tr class="even">
<td>A0</td>
<td>LK 4</td>
<td>C</td>
<td></td>
</tr>
<tr class="odd">
<td>A1</td>
<td>LK5</td>
<td>C</td>
<td></td>
</tr>
<tr class="even">
<td>RES0</td>
<td>LK6</td>
<td>C</td>
<td>There aren’t J4 pins for RES0/1 so have to use jumper pins. It is also possible to hard-wire resolution pins RES0/1, but device tree would need to be changed accordingly.</td>
</tr>
<tr class="odd">
<td>RES1</td>
<td>LK7</td>
<td>C</td>
<td>There aren’t J4 pins for RES0/1 so have to use jumper pins. It is also possible to hard-wire resolution pins RES0/1, but device tree would need to be changed accordingly.</td>
</tr>
<tr class="even">
<td>SOE</td>
<td>LK9</td>
<td>B</td>
<td></td>
</tr>
<tr class="odd">
<td>VDRIVE</td>
<td>LK703</td>
<td>B</td>
<td></td>
</tr>
</tbody>
</table>

##### Device Tree

Add `dtoverlay=ad2s1210` to `/boot/config.txt`.

Overlay: [ad2s1210-overlay.dts](https://raw.githubusercontent.com/analogdevicesinc/linux/rpi-6.1.y/arch/arm/boot/dts/overlays/ad2s1210-overlay.dts)

##### Sample Images

Eval board connections:

![](/resources/tools-software/linux-drivers/iio-resolver/img_20231206_135017785_hdr.jpg){width="400"}

Raspberry Pi connections:

![](/resources/tools-software/linux-drivers/iio-resolver/img_20231206_135039086.jpg){width="400"}

#### Zedboard

![](/resources/tools-software/linux-drivers/iio-resolver/img_20231207_080341.jpg){width="400"}

See [ad2s1210_sdz](/resources/eval/user-guides/ad2s1210_sdz) for a detailed setup guide

More Information
----------------

![iio_snippets#iio pointers&noheader&firstseconly&noeditbtn](/page>software/linux/docs/iio/iio_snippets#iio pointers&noheader&firstseconly&noeditbtn)
