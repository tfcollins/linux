---
wiki-source: https://wiki.analog.com/resources/tools-software/linux-drivers/sound/adau1372
title: ADAU1372: Quad ADC, Dual DAC, Low Latency, Low Power Codec
---

# ADAU1372 Sound CODEC Linux Driver

### Supported Devices

-   [ADAU1372](adi>ADAU1372)

### Evaluation Boards

-   [EVAL-ADAU1372](adi>EVAL-ADAU1372)

## Source Code

#### Status

<table>
<thead>
<tr class="header">
<th>Source</th>
<th>Mainlined?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="linux.github&gt;asoc-adau1372?sound/soc/codecs/adau1372.c">git</a></td>
<td><a href="git.linux.org&gt;sound/soc/codecs/adau1372.c">WiP</a></td>
</tr>
</tbody>
</table>

#### Files

<table>
<thead>
<tr class="header">
<th>Function</th>
<th>File</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>driver</td>
<td><a href="linux.github&gt;asoc-adau1372?sound/soc/codecs/adau1372.c">sound/soc/codecs/adau1372.c</a></td>
</tr>
<tr class="even">
<td>driver</td>
<td><a href="linux.github&gt;asoc-adau1372?sound/soc/codecs/adau1372-i2c.c">sound/soc/codecs/adau1372-i2c.c</a></td>
</tr>
<tr class="odd">
<td>driver</td>
<td><a href="linux.github&gt;asoc-adau1372?sound/soc/codecs/adau1372-spi.c">sound/soc/codecs/adau1372-spi.c</a></td>
</tr>
<tr class="even">
<td>include</td>
<td><a href="linux.github&gt;asoc-adau1372?sound/soc/codecs/adau1372.h">sound/soc/codecs/adau1372.h</a></td>
</tr>
</tbody>
</table>

## Example device initialization

![](page>software/linux/docs/platform_and_bus_model#Platform Data&noheader&firstseconly&noeditbtn)

#### I2C

![](page>software/linux/docs/platform_and_bus_model#Declaring I2C devices&firstseconly&noeditbtn)

The I2C device id depends on the ADDR0 and ADDR1 pin settings and needs to be set according to your board setup.

<table>
<thead>
<tr class="header">
<th>ADDR1</th>
<th>ADDR0</th>
<th>I2C device id</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0x3c</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>0x3d</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0x3e</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>0x3f</td>
</tr>
</tbody>
</table>

In this example we assume ADDR0=0 and ADDR1=0.

``` c
static struct i2c_board_info __initdata bfin_i2c_board_info[] = {

    [--snip--]
    {
        I2C_BOARD_INFO("adau1372", 0x3c),
    },
    [--snip--]
}

```

``` c
static int __init stamp_init(void)
{
    [--snip--]
    i2c_register_board_info(0, bfin_i2c_board_info,
                ARRAY_SIZE(bfin_i2c_board_info));
    [--snip--]

    return 0;
}
arch_initcall(board_init);
```

#### SPI

![](page>software/linux/docs/platform_and_bus_model#Declaring SPI slave devices&firstseconly&noeditbtn)

### ASoC DAPM Widgets

The driver registers a set of input, output and supply DAPM widgets which represent the physical input and output signals of the device. For maximum power-saving these are widgets should be used in the machine driver DAPM routing to accurately model the external connections of the device.

<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AIN0</td>
<td>ADC0 Single-ended Analog Input</td>
</tr>
<tr class="even">
<td>AIN1</td>
<td>ADC1 Single-ended Analog Input</td>
</tr>
<tr class="odd">
<td>AIN2</td>
<td>ADC2 Single-ended Analog Input</td>
</tr>
<tr class="even">
<td>AIN3</td>
<td>ADC3 Single-ended Analog Input</td>
</tr>
<tr class="odd">
<td>DMIC0_1</td>
<td>Digital Microphone Input Channel 0 and 1</td>
</tr>
<tr class="even">
<td>DMIC2_3</td>
<td>Digital Microphone Input Channel 2 and 3</td>
</tr>
<tr class="odd">
<td>MICBIAS0</td>
<td>Bias Voltage for Electret Microphone</td>
</tr>
<tr class="even">
<td>MICBIAS1</td>
<td>Bias Voltage for Electret Microphone</td>
</tr>
<tr class="odd">
<td>HPOUTL</td>
<td>Left Headphone Output</td>
</tr>
<tr class="even">
<td>HPOUTR</td>
<td>Right Headphone Output</td>
</tr>
</tbody>
</table>

### ALSA Controls

<table>
<tbody>
<tr class="odd">
<td>&lt; - 16em &gt;</td>
</tr>
<tr class="even">
<td>Name</td>
</tr>
<tr class="odd">
<td>ADC 0 Capture Switch</td>
</tr>
<tr class="even">
<td>ADC 0 Capture Volume</td>
</tr>
<tr class="odd">
<td>ADC 0+1 Bias</td>
</tr>
<tr class="even">
<td>ADC 0+1 High-Pass-Filter</td>
</tr>
<tr class="odd">
<td>ADC 1 Capture Switch</td>
</tr>
<tr class="even">
<td>ADC 1 Capture Volume</td>
</tr>
<tr class="odd">
<td>ADC 2 Capture Switch</td>
</tr>
<tr class="even">
<td>ADC 2 Capture Volume</td>
</tr>
<tr class="odd">
<td>ADC 2+3 Bias</td>
</tr>
<tr class="even">
<td>ADC 2+3 High-Pass-Filter</td>
</tr>
<tr class="odd">
<td>ADC 3 Capture Switch</td>
</tr>
<tr class="even">
<td>ADC 3 Capture Volume</td>
</tr>
<tr class="odd">
<td>AFE 0+1 Bias</td>
</tr>
<tr class="even">
<td>AFE 2+3 Bias</td>
</tr>
<tr class="odd">
<td>DAC 0 Mux</td>
</tr>
<tr class="even">
<td>DAC 0 Playback Switch</td>
</tr>
<tr class="odd">
<td>DAC 0 Playback Volume</td>
</tr>
<tr class="even">
<td>DAC 0+1 Bias</td>
</tr>
<tr class="odd">
<td>DAC 1 Mux</td>
</tr>
<tr class="even">
<td>DAC 1 Playback Switch</td>
</tr>
<tr class="odd">
<td>DAC 1 Playback Volume</td>
</tr>
<tr class="even">
<td>Decimator 0+1 Capture Mux</td>
</tr>
<tr class="odd">
<td>Decimator 2+3 Capture Mux</td>
</tr>
<tr class="even">
<td>Headphone Bias</td>
</tr>
<tr class="odd">
<td>Input ASRC Playback Mux</td>
</tr>
<tr class="even">
<td>Microphone Bias</td>
</tr>
<tr class="odd">
<td>Output ASRC0 Mux</td>
</tr>
<tr class="even">
<td>Output ASRC1 Mux</td>
</tr>
<tr class="odd">
<td>Output ASRC2 Mux</td>
</tr>
<tr class="even">
<td>Output ASRC3 Mux</td>
</tr>
<tr class="odd">
<td>PGA 0 Boost Capture Volume</td>
</tr>
<tr class="even">
<td>PGA 0 Capture Switch</td>
</tr>
<tr class="odd">
<td>PGA 0 Capture Volume</td>
</tr>
<tr class="even">
<td>PGA 1 Boost Capture Volume</td>
</tr>
<tr class="odd">
<td>PGA 1 Capture Switch</td>
</tr>
<tr class="even">
<td>PGA 1 Capture Volume</td>
</tr>
<tr class="odd">
<td>PGA 2 Boost Capture Volume</td>
</tr>
<tr class="even">
<td>PGA 2 Capture Switch</td>
</tr>
<tr class="odd">
<td>PGA 2 Capture Volume</td>
</tr>
<tr class="even">
<td>PGA 3 Boost Capture Volume</td>
</tr>
<tr class="odd">
<td>PGA 3 Capture Switch</td>
</tr>
<tr class="even">
<td>PGA 3 Capture Volume</td>
</tr>
<tr class="odd">
<td>Serial Output 0 Capture Mux</td>
</tr>
<tr class="even">
<td>Serial Output 1 Capture Mux</td>
</tr>
<tr class="odd">
<td>Serial Output 2 Capture Mux</td>
</tr>
<tr class="even">
<td>Serial Output 3 Capture Mux</td>
</tr>
<tr class="odd">
<td>Serial Output 4 Capture Mux</td>
</tr>
<tr class="even">
<td>Serial Output 5 Capture Mux</td>
</tr>
<tr class="odd">
<td>Serial Output 6 Capture Mux</td>
</tr>
<tr class="even">
<td>Serial Output 7 Capture Mux</td>
</tr>
</tbody>
</table>

### DAI configuration

The codec driver registers one DAI: **adau1372**

This DAI has a capture and a playback interface which share the clocking and are synchronous to each other. Which means they have to run in the same configuration.

#### Supported DAI formats

<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Supported by driver</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SND_SOC_DAIFMT_I2S</td>
<td>yes</td>
<td>I2S mode</td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_RIGHT_J</td>
<td>no</td>
<td>Right Justified mode</td>
</tr>
<tr class="odd">
<td>SND_SOC_DAIFMT_LEFT_J</td>
<td>yes</td>
<td>Left Justified mode</td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_DSP_A</td>
<td>yes</td>
<td>data MSB after FRM LRC</td>
</tr>
<tr class="odd">
<td>SND_SOC_DAIFMT_DSP_B</td>
<td>yes</td>
<td>data MSB during FRM LRC</td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_AC97</td>
<td>no</td>
<td>AC97 mode</td>
</tr>
<tr class="odd">
<td>SND_SOC_DAIFMT_PDM</td>
<td>no</td>
<td>Pulse density modulation</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>SND_SOC_DAIFMT_NB_NF</td>
<td>yes</td>
<td>Normal bit- and frameclock</td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_NB_IF</td>
<td>yes</td>
<td>Normal bitclock, inverted frameclock</td>
</tr>
<tr class="odd">
<td>SND_SOC_DAIFMT_IB_NF</td>
<td>yes</td>
<td>Inverted frameclock, normal bitclock</td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_IB_IF</td>
<td>yes</td>
<td>Inverted bit- and frameclock</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_CBM_CFM</td>
<td>yes</td>
<td>Codec bit- and frameclock master</td>
</tr>
<tr class="odd">
<td>SND_SOC_DAIFMT_CBS_CFM</td>
<td>no</td>
<td>Codec bitclock slave, frameclock master</td>
</tr>
<tr class="even">
<td>SND_SOC_DAIFMT_CBM_CFS</td>
<td>no</td>
<td>Codec bitclock master, frameclock slave</td>
</tr>
<tr class="odd">
<td>SND_SOC_DAIFMT_CBS_CFS</td>
<td>yes</td>
<td>Codec bit- and frameclock slave</td>
</tr>
</tbody>
</table>

#### DAI sysclk

#### Example DAI configuration

### TDM configuration

The ADAU1372 has TDM support.

-   The number of slots can be either 2, 4 or 8.
-   The slot width can be 16 or 32.
-   The slot mask can select any combination of channels on both TX and RX

Example TDM configuration:

``` c
    ret = snd_soc_dai_set_tdm_slot(codec_dai, 0x3, 0x3, 8, 24);
```

### More information

![](page>resources/tools-software/linux-drivers/need_help#need help&noheader&firstseconly&noeditbtn)
